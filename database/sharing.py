import uuid
from datetime import datetime
from .connection import get_async_connection
import logging

# SQL Schema needed for these features:
#
# CREATE TABLE lkp_document_share(
#     system_id INT IDENTITY(1,1) PRIMARY KEY,
#     token VARCHAR(64) NOT NULL UNIQUE,
#     docnumber INT NOT NULL, -- Matches your Documents table
#     created_by int NOT NULL, -- system_id of the person from PEOPLE table that can be retrieved by email
#     create_date DATETIME DEFAULT GETDATE(),
#     expiry DATETIME NULL,
#     is_active BIT DEFAULT 1
# );
#
# CREATE TABLE lkp_share_logs (
#     system_id INT IDENTITY(1,1) PRIMARY KEY,
#     share_id INT NOT NULL FOREIGN KEY REFERENCES document_shares(system_id),
#     viewer_email VARCHAR(255) NULL, -- Null if anonymous, or captured from SSO
#     access_date DATETIME DEFAULT GETDATE(),
# );

# CREATE TABLE lkp_share_otp (
#     system_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
#     share_token VARCHAR2(64) NOT NULL,
#     email VARCHAR2(255) NOT NULL,
#     otp_code VARCHAR2(10) NOT NULL,
#     expiry_date DATE NOT NULL,
#     is_used NUMBER(1) DEFAULT 0
# );

async def create_share_link(document_id, created_by, expiry_date=None):
    """
    Creates a new share token for a document (Async).
    """
    conn = await get_async_connection()
    if not conn:
        raise Exception("Database connection failed")

    token = str(uuid.uuid4())

    # Oracle uses :placeholder syntax
    query = """
        INSERT INTO lkp_document_share (system_id, token, docnumber, created_by, expiry, create_date, is_active, disabled)
        VALUES ((SELECT NVL(MAX(SYSTEM_ID), 0) + 1 FROM lkp_document_share), :token, :doc_id, :created_by, :expiry, SYSDATE, 1, 0)
    """

    try:
        async with conn.cursor() as cursor:
            # Handle expiry date formatting if needed, or pass as datetime object
            await cursor.execute(query, {
                'token': token,
                'doc_id': document_id,
                'created_by': created_by,
                'expiry': expiry_date
            })
            await conn.commit()
            return token
    except Exception as e:
        await conn.rollback()
        raise e
    finally:
        await conn.close()

async def get_share_details(token):
    """
    Retrieves share details (Async).
    """
    conn = await get_async_connection()
    if not conn: return None

    query = """
        SELECT system_id, docnumber, created_by, expiry, is_active 
        FROM lkp_document_share 
        WHERE token = :token
    """

    try:
        async with conn.cursor() as cursor:
            await cursor.execute(query, {'token': token})
            row = await cursor.fetchone()

            if row:
                share_id, doc_id, created_by, expiry, is_active = row

                # Check expiration
                if expiry and expiry < datetime.now():
                    return None

                if not is_active:
                    return None

                return {
                    "share_id": share_id,
                    "document_id": doc_id,
                    "created_by": created_by,
                    "expiry_date": expiry
                }
            return None
    finally:
        await conn.close()

async def log_share_access(share_id, viewer_email):
    """
    Logs the access of a shared document (Async).
    """
    conn = await get_async_connection()
    if not conn: return

    query = """
        INSERT INTO lkp_share_logs (system_id, share_id, viewer_email, access_date, disabled)
        VALUES ((SELECT NVL(MAX(SYSTEM_ID), 0) + 1 FROM lkp_share_logs), :share_id, :viewer_email, SYSDATE, 0)
    """

    try:
        async with conn.cursor() as cursor:
            await cursor.execute(query, {
                'share_id': share_id,
                'viewer_email': viewer_email
            })
            await conn.commit()
    except Exception as e:
        print(f"Failed to log access: {e}")
    finally:
        await conn.close()

async def get_access_stats(token):
    """
    Returns how many times a link has been accessed (Async).
    """
    conn = await get_async_connection()
    if not conn: return {"access_count": 0, "last_accessed": None}

    query = """
        SELECT COUNT(*), MAX(access_date)
        FROM lkp_share_logs l
        JOIN lkp_document_share s ON l.share_id = s.system_id
        WHERE s.token = :token
    """

    try:
        async with conn.cursor() as cursor:
            await cursor.execute(query, {'token': token})
            row = await cursor.fetchone()

            if row:
                return {
                    "access_count": row[0],
                    "last_accessed": row[1]
                }
            return {"access_count": 0, "last_accessed": None}
    finally:
        await conn.close()

async def get_system_id_by_username(username: str) -> int | None:
    """
    Retrieves the SYSTEM_ID from the PEOPLE table for a given username.
    """
    conn = await get_async_connection()
    if not conn: return None

    try:
        async with conn.cursor() as cursor:
            await cursor.execute(
                "SELECT SYSTEM_ID FROM PEOPLE WHERE UPPER(USER_ID) = UPPER(:username)",
                {'username': username}
            )
            row = await cursor.fetchone()
            return row[0] if row else None
    except Exception as e:
        print(f"Error fetching user system_id: {e}")
        return None
    finally:
        await conn.close()

async def save_otp(token, email, otp_code, validity_minutes=10):
    """Saves an OTP to the database with an expiry time."""
    conn = await get_async_connection()
    if not conn: return False

    try:
        async with conn.cursor() as cursor:
            # Oracle SQL: SYSDATE + (Minutes / 1440) adds minutes to current time
            sql = """
                INSERT INTO lkp_share_otp (system_id, share_token, email, otp_code, expiry_date, is_used, disabled)
                VALUES ((SELECT NVL(MAX(SYSTEM_ID), 0) + 1 FROM lkp_share_otp), :token, :email, :otp, SYSDATE + :mins/1440, 0, 0)
            """
            await cursor.execute(sql, {
                'token': token,
                'email': email,
                'otp': otp_code,
                'mins': validity_minutes
            })
            await conn.commit()
            return True
    except Exception as e:
        logging.error(f"Error saving OTP to DB: {e}")
        return False
    finally:
        await conn.close()

async def verify_otp(token, email, otp_code):
    """Verifies an OTP and marks it as used if valid."""
    conn = await get_async_connection()
    if not conn: return False

    try:
        async with conn.cursor() as cursor:
            # 1. Check for valid, unused, non-expired OTP
            sql = """
                SELECT system_id 
                FROM lkp_share_otp 
                WHERE share_token = :token 
                AND email = :email 
                AND otp_code = :otp 
                AND is_used = 0 
                AND expiry_date > SYSDATE
                ORDER BY expiry_date DESC 
                FETCH FIRST 1 ROWS ONLY
            """
            await cursor.execute(sql, {'token': token, 'email': email, 'otp': otp_code})
            row = await cursor.fetchone()

            if row:
                system_id = row[0]
                # 2. Mark as used (Consume the OTP)
                update_sql = "UPDATE lkp_share_otp SET is_used = 1 WHERE system_id = :id"
                await cursor.execute(update_sql, {'id': system_id})
                await conn.commit()
                return True

            return False

    except Exception as e:
        logging.error(f"Error verifying OTP: {e}")
        return False
    finally:
        await conn.close()