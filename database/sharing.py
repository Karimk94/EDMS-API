import uuid
from datetime import datetime
from .connection import get_async_connection
import logging

# SQL Schema needed for these features:
#
# CREATE TABLE lkp_share_type (
#     system_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
#     name VARCHAR2(20) NOT NULL UNIQUE,
#     description VARCHAR2(100),
#     disabled NUMBER(1) DEFAULT 0
# );
# -- Values: (1, 'file'), (2, 'folder')
#
# CREATE TABLE lkp_document_share(
#     system_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
#     token VARCHAR2(64) NOT NULL UNIQUE,
#     docnumber NUMBER NULL, -- Matches PROFILE.DOCNUMBER (NULL if folder share)
#     folder_id NUMBER NULL, -- References FOLDER_ITEM.SYSTEM_ID (NULL if file share)
#     share_type_id NUMBER DEFAULT 1 REFERENCES lkp_share_type(system_id), -- FK to lkp_share_type
#     created_by NUMBER NOT NULL, -- system_id from PEOPLE table
#     target_email VARCHAR2(255) NULL, -- If set, only this email can access (must be @rta.ae)
#     create_date DATE DEFAULT SYSDATE,
#     expiry DATE NULL,
#     is_active NUMBER(1) DEFAULT 1,
#     disabled NUMBER(1) DEFAULT 0
# );

# Share type constants (matching lkp_share_type.system_id)
# CREATE TABLE lkp_share_logs (
#     system_id INT IDENTITY(1,1) PRIMARY KEY,
#     share_id INT NOT NULL FOREIGN KEY REFERENCES document_shares(system_id),
#     viewer_email VARCHAR(255) NULL, -- Null if anonymous, or captured from SSO
#     access_date DATETIME DEFAULT GETDATE(),
# );

# CREATE TABLE lkp_share_otp (
#     system_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
#     share_token VARCHAR2(64) NOT NULL,
#     email VARCHAR2(255) NOT NULL,
#     otp_code VARCHAR2(10) NOT NULL,
#     expiry_date DATE NOT NULL,
#     is_used NUMBER(1) DEFAULT 0
# );

ALLOWED_DOMAIN = "@rta.ae"
SHARE_TYPE_FILE = 1
SHARE_TYPE_FOLDER = 2

async def create_share_link(document_id=None, folder_id=None, created_by=None, expiry_date=None, target_email=None, share_type='file'):
    """
    Creates a new share token for a document or folder (Async).

    Args:
        document_id: The document ID to share (for file shares)
        folder_id: The folder ID to share (for folder shares)
        created_by: The user system_id creating the share
        expiry_date: Optional expiry date for the link
        target_email: Optional specific email that can access (must be @rta.ae domain)
        share_type: 'file' or 'folder'
    """
    conn = await get_async_connection()
    if not conn:
        raise Exception("Database connection failed")

    # Validate target_email domain if provided
    if target_email:
        target_email = target_email.strip().lower()
        if not target_email.endswith(ALLOWED_DOMAIN.lower()):
            raise ValueError(f"Target email must be from {ALLOWED_DOMAIN} domain")

    # Validate share type and IDs
    if share_type == 'file' and not document_id:
        raise ValueError("document_id is required for file shares")
    if share_type == 'folder' and not folder_id:
        raise ValueError("folder_id is required for folder shares")

    # Convert share_type string to ID
    share_type_id = SHARE_TYPE_FOLDER if share_type == 'folder' else SHARE_TYPE_FILE

    token = str(uuid.uuid4())

    # Oracle uses :placeholder syntax
    query = """
        INSERT INTO lkp_document_share (system_id, token, docnumber, folder_id, share_type_id, created_by, target_email, expiry, create_date, is_active, disabled)
        VALUES ((SELECT NVL(MAX(SYSTEM_ID), 0) + 1 FROM lkp_document_share), :token, :doc_id, :folder_id, :share_type_id, :created_by, :target_email, :expiry, SYSDATE, 1, 0)
    """

    try:
        async with conn.cursor() as cursor:
            await cursor.execute(query, {
                'token': token,
                'doc_id': document_id if share_type == 'file' else None,
                'folder_id': folder_id if share_type == 'folder' else None,
                'share_type_id': share_type_id,
                'created_by': created_by,
                'target_email': target_email,
                'expiry': expiry_date
            })
            await conn.commit()
            return token
    except Exception as e:
        await conn.rollback()
        raise e
    finally:
        await conn.close()

async def get_share_details(token):
    """
    Retrieves share details (Async).
    """
    conn = await get_async_connection()
    if not conn: return None

    query = """
        SELECT ds.system_id, ds.docnumber, ds.folder_id, st.name as share_type, 
               ds.created_by, ds.target_email, ds.expiry, ds.is_active 
        FROM lkp_document_share ds
        LEFT JOIN lkp_share_type st ON ds.share_type_id = st.system_id
        WHERE ds.token = :token
    """

    try:
        async with conn.cursor() as cursor:
            await cursor.execute(query, {'token': token})
            row = await cursor.fetchone()

            if row:
                share_id, doc_id, folder_id, share_type, created_by, target_email, expiry, is_active = row

                # Check expiration
                if expiry and expiry < datetime.now():
                    return None

                if not is_active:
                    return None

                return {
                    "share_id": share_id,
                    "document_id": doc_id,
                    "folder_id": folder_id,
                    "share_type": share_type or 'file',  # Default to 'file' for backward compatibility
                    "created_by": created_by,
                    "target_email": target_email,  # Will be None if not restricted
                    "expiry_date": expiry
                }
            return None
    finally:
        await conn.close()

async def log_share_access(share_id, viewer_email):
    """
    Logs the access of a shared document (Async).
    """
    conn = await get_async_connection()
    if not conn: return

    query = """
        INSERT INTO lkp_share_logs (system_id, share_id, viewer_email, access_date, disabled)
        VALUES ((SELECT NVL(MAX(SYSTEM_ID), 0) + 1 FROM lkp_share_logs), :share_id, :viewer_email, SYSDATE, 0)
    """

    try:
        async with conn.cursor() as cursor:
            await cursor.execute(query, {
                'share_id': share_id,
                'viewer_email': viewer_email
            })
            await conn.commit()
    except Exception as e:
        print(f"Failed to log access: {e}")
    finally:
        await conn.close()

async def get_access_stats(token):
    """
    Returns how many times a link has been accessed (Async).
    """
    conn = await get_async_connection()
    if not conn: return {"access_count": 0, "last_accessed": None}

    query = """
        SELECT COUNT(*), MAX(access_date)
        FROM lkp_share_logs l
        JOIN lkp_document_share s ON l.share_id = s.system_id
        WHERE s.token = :token
    """

    try:
        async with conn.cursor() as cursor:
            await cursor.execute(query, {'token': token})
            row = await cursor.fetchone()

            if row:
                return {
                    "access_count": row[0],
                    "last_accessed": row[1]
                }
            return {"access_count": 0, "last_accessed": None}
    finally:
        await conn.close()

async def get_system_id_by_username(username: str) -> int | None:
    """
    Retrieves the SYSTEM_ID from the PEOPLE table for a given username.
    """
    conn = await get_async_connection()
    if not conn: return None

    try:
        async with conn.cursor() as cursor:
            await cursor.execute(
                "SELECT SYSTEM_ID FROM PEOPLE WHERE UPPER(USER_ID) = UPPER(:username)",
                {'username': username}
            )
            row = await cursor.fetchone()
            return row[0] if row else None
    except Exception as e:
        print(f"Error fetching user system_id: {e}")
        return None
    finally:
        await conn.close()

async def save_otp(token, email, otp_code, validity_minutes=5):
    """Saves an OTP to the database with an expiry time."""
    conn = await get_async_connection()
    if not conn: return False

    try:
        async with conn.cursor() as cursor:
            # Oracle SQL: SYSDATE + (Minutes / 1440) adds minutes to current time
            sql = """
                INSERT INTO lkp_share_otp (system_id, share_token, email, otp_code, expiry_date, is_used, disabled)
                VALUES ((SELECT NVL(MAX(SYSTEM_ID), 0) + 1 FROM lkp_share_otp), :token, :email, :otp, SYSDATE + :mins/1440, 0, 0)
            """
            await cursor.execute(sql, {
                'token': token,
                'email': email,
                'otp': otp_code,
                'mins': validity_minutes
            })
            await conn.commit()
            return True
    except Exception as e:
        logging.error(f"Error saving OTP to DB: {e}")
        return False
    finally:
        await conn.close()

async def verify_otp(token, email, otp_code):
    """Verifies an OTP and marks it as used if valid."""
    conn = await get_async_connection()
    if not conn: return False

    try:
        async with conn.cursor() as cursor:
            # 1. Check for valid, unused, non-expired OTP
            sql = """
                SELECT system_id 
                FROM lkp_share_otp 
                WHERE share_token = :token 
                AND LOWER(email) = LOWER(:email)
                AND otp_code = :otp 
                AND is_used = 0 
                AND expiry_date > SYSDATE
                ORDER BY expiry_date DESC 
                FETCH FIRST 1 ROWS ONLY
            """
            await cursor.execute(sql, {'token': token, 'email': email, 'otp': otp_code})
            row = await cursor.fetchone()

            if row:
                system_id = row[0]
                # 2. Mark as used (Consume the OTP)
                update_sql = "UPDATE lkp_share_otp SET is_used = 1 WHERE system_id = :id"
                await cursor.execute(update_sql, {'id': system_id})
                await conn.commit()
                return True

            return False

    except Exception as e:
        logging.error(f"Error verifying OTP: {e}")
        return False
    finally:
        await conn.close()

async def check_viewer_access(token: str, viewer_email: str, hours_valid: int = 24) -> bool:
    """
    Checks if a viewer has verified access within the valid time window.
    """
    try:
        # First get the share_id from the token
        share_info = await get_share_details(token)
        if not share_info:
            return False

        share_id = share_info['share_id']

        conn = await get_async_connection()
        if not conn:
            return False

        try:
            # Check for access within the last X hours
            query = """
                SELECT COUNT(*) as access_count 
                FROM lkp_share_logs 
                WHERE share_id = :share_id 
                AND LOWER(viewer_email) = LOWER(:viewer_email)
                AND access_date >= SYSDATE - :hours_valid/24
            """

            async with conn.cursor() as cursor:
                await cursor.execute(query, {
                    'share_id': share_id,
                    'viewer_email': viewer_email,
                    'hours_valid': hours_valid
                })
                row = await cursor.fetchone()

                return row is not None and row[0] > 0
        finally:
            await conn.close()

    except Exception as e:
        logging.error(f"Error checking viewer access: {e}")
        return False

async def validate_target_email_access(token: str, viewer_email: str) -> tuple[bool, str | None]:
    """
    Validates if the viewer email is allowed to access the shared document.

    Returns:
        tuple: (is_allowed, error_message)
        - If target_email is set, only that email can access
        - If target_email is None, any @rta.ae email can access
    """
    share_info = await get_share_details(token)
    if not share_info:
        return False, "Link is invalid or expired"

    target_email = share_info.get('target_email')
    viewer_email_lower = viewer_email.strip().lower()

    # Check domain restriction first
    if not viewer_email_lower.endswith(ALLOWED_DOMAIN.lower()):
        return False, f"Access restricted to {ALLOWED_DOMAIN} emails only."

    # If target_email is set, check if it matches
    if target_email:
        target_email_lower = target_email.strip().lower()
        if viewer_email_lower != target_email_lower:
            return False, "This link is restricted to a specific recipient. Please contact the sender if you believe this is an error."

    return True, None